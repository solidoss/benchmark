It depends on what you mean by “thread safe”, but yes, thread safety is part of specification of all of the standard C++ smart pointers.

A type provides the basic thread safety guarantee if you can access two distinct objects of that type from two different threads simultaneously without causing a race condition.

Beginners to multithreading often use the term “thread safe” to mean a type that has an interface with built-in mutual exclusion. Such a type has the quality that a single instance of an object can be touched by two or more threads without causing a race condition. A multithreaded queue is a common type that falls into this category. A thread may read from the queue while another thread simultaneously writes to it. Even such types need to be very specific about which operations are thread safe. A multithreaded queue, for example, might or might not allow multiple simultaneous readers or multiple simultaneous writers.

So, back to C++ smart pointers. The C++ standard defines three kinds of smart pointers in the standard library: unique_ptr, shared_ptr, and weak_ptr. They all provide the basic thread safety guarantee. In the case of shared_ptr and weak_ptr two copies of the same original pointer (which are distinct objects, despite pointing to the same object) share a common reference count. The standard explicitly says that if these copies are accessed or modified simultaneously (i.e., dereferenced, assigned, or destroyed), then the reference count must be maintained correctly. In practice, this means that the implementation must update the reference count atomically. Note that if two threads try to modify the same instance of any one of these pointers, then all bets are off.

I should mention that C++ allows the user to program their own smart pointer classes. Whether those pointer classes meet the basic thread safety guarantee or not is up to the person who specified and implements them.

Disclaimer : there are reasons why it's a good time to be a programmer but that's a different question

I would say that its hard to be a programmer today, for the same reasons that its hard to be a small startup today After the end of the startup era. It has to do with the ratio of solved vs unsolved problems a programmer encounters on a daily basis.

20 years ago, you might have had fun implementing and figuring out a lazy or on demand client/server data feed. Chunking the data according to some scheme, figuring out an efficient and optimized memory layout and binary representation for your data, moving it from files or a DB accross the network and keeping it all in sync so the client wont choke out of memory. This taks could require learning new protocols, implementing custom data structures etc.. In other words, it could be kind of fun. Or even earlier people would write their own libraries of data structures and have their own data types that they would define in C. People got to implement their own custom sorting routines and standard libraries. This type of work can be very engaging.

Slowly (or not so slowly) things got standardized. We got GC languages. Suddenly almost (almost!) anything you could be asked to code that was restricted to single machine was very much a solved problem. The thing about solved problems is that no one really cares about them. At least not people who are driven by curiosity. Not the explorers.

Look at when the iPhone first showed up. People had a lot of fun innovating new apps and ideas on them. It was new, fresh territory to explore. So even if your boring, Lumberg , Innatech inc company asked you to creat a new smart phone app that would allow them to manage the Y2k (Office Space - Wikipedia) , it could be an exciting thing. Today its all been done. Theres a framework or a library that does it all for you and you just paste together the plumbing.

Sure, todays era does have its share of cool dragons to slay. AI, VR, embedded, etc.. but these beasts are too big for a programmer to get to play the lone hero anymore. You need a team, you need specialists. Even the specialists complain that all they are doing is tweaking parameters in tensor flow…

On the other hand if you are the type of person that likes to churn through solved problems, like reworking your typical web-apps, mobile apps, web sites, lamp apps, into some custom use case or perfecting them etc… then you might consider this a great time to be a programmer since it just keeps getting easier and easier for this type of thing.
